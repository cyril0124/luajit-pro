use std::cell::UnsafeCell;
use std::collections::HashMap;
use std::{cell::RefCell, env, str, vec};

use darklua_core::generator::LuaGenerator;
use darklua_core::rules::{Rule, RuleConfiguration, RulePropertyValue};
use mlua::prelude::*;

pub fn lua_dostring(code_name: &str, code: &str) -> (String, bool) {
    thread_local! {
        static LUA: UnsafeCell<Lua> = UnsafeCell::new({
            let lua = unsafe { Lua::unsafe_new() };

            let macro_engine_script = include_str!("lua/macro_engine.lua");
            let macro_engine_chunk = lua.load(macro_engine_script).set_name("lua/macro_engine.lua");
            if let Err(e) = macro_engine_chunk.exec() {
                panic!("Failed to load macro_engine: {}", e);
            };

            lua
        });
    }
    LUA.with(|lua| {
        let lua = unsafe { &mut *lua.get() };
        lua.globals()
            .set("__code_name__", code_name)
            .expect("Failed to set __code_name__");
        let ret_val = lua.load(code).eval::<mlua::Value>();

        // Code generated by `output/out/o/outputf/outf/of` will be saved in `output_str`
        let get_output: LuaFunction = lua.globals().get("get_output").unwrap();
        let output_str: String = get_output.call::<String>(()).unwrap();

        let check_keep_line: LuaFunction = lua.globals().get("_check_keep_line").unwrap();
        let keep_line: bool = check_keep_line.call::<bool>(()).unwrap();

        (
            output_str
                + (match ret_val {
                    Ok(value) => match value {
                        mlua::Value::String(s) => s.to_str().unwrap().to_owned(),
                        mlua::Value::Nil => "".to_owned(),
                        _ => panic!(
                            "Expected string bug got {:?}\n----------\n{}\n----------",
                            value, code
                        ),
                    },
                    Err(err) => panic!(
                        "Error evaluating lua code, {}\n----------\n{}\n----------",
                        err, code
                    ),
                })
                .as_str(),
            keep_line,
        )
    })
}

pub fn convert_teal_to_lua(input_file_name: &str, syntax_only: bool) -> String {
    thread_local! {
        static LUA: UnsafeCell<Lua> = UnsafeCell::new({
            let lua = unsafe { Lua::unsafe_new() };

            let tl_script = include_str!("../tl/tl.lua");
            let tl_chunk = lua.load(tl_script).set_name("tl/tl.lua");
            if let Err(e) = tl_chunk.exec() {
                panic!("Failed to load tl/tl: {}", e);
            };

            let teal_to_lua_script = include_str!("lua/teal_to_lua.lua");
            let teal_to_lua_chunk = lua.load(teal_to_lua_script).set_name("teal_to_lua.lua");
            if let Err(e) = teal_to_lua_chunk.exec() {
                panic!("Failed to load teal_to_lua: {}", e);
            };

            lua
        });
    }
    LUA.with(|lua| {
        let lua = unsafe { &mut *lua.get() };

        let func: mlua::Function = lua.globals().get("teal_to_lua").unwrap();
        let lua_code = func
            .call::<String>((input_file_name, syntax_only))
            .expect("Failed to call teal_to_lua function");
        lua_code
    })
}

pub fn convert_luau_to_lua(input: &str) -> String {
    let resources: darklua_core::Resources = darklua_core::Resources::from_memory();
    let context = darklua_core::rules::ContextBuilder::new(".", &resources, input).build();
    let mut block = darklua_core::Parser::default()
        .preserve_tokens()
        .parse(input)
        .unwrap_or_else(|error| {
            panic!(
                "[convert_luau_to_lua] darklua_core could not parse content: {:?}\ncontent:\n{}",
                error, input
            );
        });

    darklua_core::rules::RemoveCompoundAssignment::default()
        .process(&mut block, &context)
        .expect("Failed to remove compound assignment");
    darklua_core::rules::RemoveFloorDivision::default()
        .process(&mut block, &context)
        .expect("Failed to remove floor division");
    darklua_core::rules::RemoveTypes::default()
        .process(&mut block, &context)
        .expect("Failed to remove types");
    darklua_core::rules::RemoveIfExpression::default()
        .process(&mut block, &context)
        .expect("Failed to remove if expression");
    darklua_core::rules::RemoveContinue::default()
        .process(&mut block, &context)
        .expect("Failed to remove continue");
    darklua_core::rules::RemoveInterpolatedString::default()
        .process(&mut block, &context)
        .expect("Failed to remove interpolated string");
    darklua_core::rules::RemoveUnusedIfBranch::default()
        .process(&mut block, &context)
        .expect("Failed to remove unused if branches");
    darklua_core::rules::RemoveEmptyDo::default()
        .process(&mut block, &context)
        .expect("Failed to remove empty do");
    darklua_core::rules::RemoveUnusedVariable::default()
        .process(&mut block, &context)
        .expect("Failed to remove unused variables");

    let mut generator = darklua_core::generator::TokenBasedLuaGenerator::new(input);
    generator.write_block(&block);
    let lua_code = generator.into_string();

    lua_code
}

pub fn inject_global_vals(input: &str, input_param_table: HashMap<&str, String>) -> String {
    let resources: darklua_core::Resources = darklua_core::Resources::from_memory();
    let context = darklua_core::rules::ContextBuilder::new(".", &resources, input).build();
    let mut block = darklua_core::Parser::default()
        .preserve_tokens()
        .parse(input)
        .unwrap_or_else(|error| {
            panic!(
                "[inject_global_vals] darklua_core could not parse content: {:?}\ncontent:\n{}",
                error, input
            );
        });

    for (key, value) in input_param_table {
        darklua_core::rules::InjectGlobalValue::boolean(key, value == "true" || value == "1")
            .process(&mut block, &context)
            .expect("Failed to inject global value");
    }
    darklua_core::rules::RemoveUnusedIfBranch::default()
        .process(&mut block, &context)
        .expect("Failed to remove unused if branch");
    darklua_core::rules::RemoveEmptyDo::default()
        .process(&mut block, &context)
        .expect("Failed to remove empty do");
    darklua_core::rules::RemoveUnusedVariable::default()
        .process(&mut block, &context)
        .expect("Failed to remove unused variables");

    let mut generator = darklua_core::generator::TokenBasedLuaGenerator::new(input);
    generator.write_block(&block);
    let lua_code = generator.into_string();

    lua_code
}

pub fn remove_lua_comments(input: &str) -> String {
    let resources = darklua_core::Resources::from_memory();
    let context = darklua_core::rules::ContextBuilder::new(".", &resources, input).build();
    let mut block = darklua_core::Parser::default()
        .preserve_tokens()
        .parse(input)
        .unwrap_or_else(|error| {
            panic!("could not parse content: {:?}\ncontent:\n{}\norigin_code:\n----------------------\n{input}\n----------------------", error, input);
        });

    let mut rule = darklua_core::rules::RemoveComments::default();
    rule.configure({
        let mut properties = HashMap::new();
        properties.insert(
            "except".to_string(),
            RulePropertyValue::StringList(vec![
                // `--[[@comp_time_enum]]` is a compile time annotation used by `lua_optimizer`
                r#"^--\[\[@comp_time_enum\]\]"#.to_string(),
                // `--[[@used]]` is a compile time annotation used by `lua_optimizer`
                r#"^--\[\[@used\]\]"#.to_string(),
                // Keep anything after `--#`, used with `keep_line()` in compile time block to prevent error while removing comments
                r#"^--#"#.to_string(),
            ]),
        );
        properties
    })
    .expect("Failed to configure rule");

    rule.process(&mut block, &context)
        .expect("rule should suceed");
    let mut generator = darklua_core::generator::TokenBasedLuaGenerator::new(input);
    generator.write_block(&block);
    let lua_code = generator.into_string();

    lua_code
}

pub fn format_lua_code(input: &str) -> String {
    let ast = full_moon::parse(&input).expect("Failed to parse generated AST");
    let mut cfg = stylua_lib::Config::new();
    cfg.column_width = 240;
    let ret_ast =
        stylua_lib::format_ast(ast, cfg, None, stylua_lib::OutputVerification::None).unwrap();
    ret_ast.to_string()
}
